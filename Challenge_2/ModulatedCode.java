#pragma config(Sensor, S1,     touch,          sensorEV3_Touch)
#pragma config(Sensor, S2,     gyro,           sensorEV3_Gyro)
#pragma config(Sensor, S3,     color,          sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonar,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          arm,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,           ,             tmotorEV3_Large, openLoop, driveLeft, encoder)
#pragma config(Motor,  motorC,           ,             tmotorEV3_Large, openLoop, driveRight, encoder)

//* Code automatically generated by 'ROBOTC' configuration wizard  *//

int wall;       // clockwise or anticlockwise if wall on left then clockwise else anti lockwise
int position;   // only for the case for determing the movement
int first = 0;  // empty / red room 


/* This makes the robot turn left or right depending on the value input */
void gyroTurnAnticlockwise(int degree, int value1, int value2) {
	resetGyro(S2);
	
	repeatUntil(getGyroDegrees(S4) < d) {
		setMotorSpeed(motorC, value1);
		setMotorSpeed(motorB, value2);
	}
		setMotorSpeed(motorC, 0);
		setMotorSpeed(motorB, 0);
		sleep(2000);
}

/* Getting Gyro Degrees */
void gyroTurnCLockwise(int degree, int value1, int value2) {
	resetGyro(S2);
	
	repeatUntil(getGyroDegrees(S4) > d) {
		setMotorSpeed(motorC, value1);
		setMotorSpeed(motorB, value2);
	}
		setMotorSpeed(motorC, 0);
		setMotorSpeed(motorB, 0);
		sleep(2000);
}



/* Moving Forward */
void movementRobot(int speed, long int runTime) {
	motor[motorB] = speed;
	motor[motorC] = speed;
	wait1Msec(runTime);
}


/* Break the movement */
void pauseMovement() {
	motor[motorB] = 0;
	motor[motorC] = 0;
	wait1Msec(1000);
}

/* Check if the Wall is on Right direction or not */
void isWallOnRight() {
	if(SensorValue(S4)<20) 
	   wall = 0;
	
	else {
	   playSound(soundUpwardTones);
	   wall = 1;
	}
}


/ *************************************************************************************/

/* This code tells us what starting point we are at 1,2,3 or 4 */

void startingPosition() {
   int sum = 0;
   int distance1, distance2;

   distance1 = SensorValue(S4);
   resetGyro(S2);

   gyroTurnCLockwise(85, -25, 25);
   isWallOnRight();

   resetGyro(S2);

   gyroTurnCLockwise(85, -25, 25);

   distance2 = SensorValue(S4);
   sum = distance1 + distance2;

	resetGyro(S2);

	gyroTurnCLockwise(180, -25, 25);

/* The sum of the distances is different from each point hence helping us distinguish the points we are starting at */

	if(sum > 100) { 
		if(wall == 0) 
			emptyOrRedRoom();
		else 
			position= 1 + wall;	
	 } 

	 else if(sum>45 && sum <60)
		position = 3 + wall;

	 else if(sum>60 && sum<80)
	    position = 7 + wall;
		
 else
    startingPosition();

 }


void emptyOrRedRoom() {
	playSound(soundBlip);

	while(SensorValue(S1) == 0 && getColorName(S3)!= colorRed) {
	  motor[motorB] = 25;
  	  motor[motorC] = 25;
  	}

   if (getColorName(S3) == colorRed) {
             // reaches the fire and backs away a bit.
   	movementRobot(-25,500);

  // turns 180 degrees
    resetGyro(S2);
 
    repeatUntil(getGyroDegrees(S2) > 180) {
	  setMotorSpeed(motorC,-50);
	  setMotorSpeed(motorB, 50);
    }
	
 /* reverses into the fire */
	
	movementRobot(-25, 2000);


	  // makes a 90 degree right turn (gyro value was 180 before)

	  if(wall == 0) {
	  
	  resetGyro(S2);
	  
		repeatUntil(getGyroDegrees(S2) > 90) {
			//Point turn to the left
			setMotorSpeed(motorC,0);
			setMotorSpeed(motorB, 50);
	    }
	  }

	  else {
	    resetGyro(S2);
		
		repeatUntil(getGyroDegrees(S2) < -90) {
			//Point turn to the left
			setMotorSpeed(motorC,50);
			setMotorSpeed(motorB, 0);
	    }
	  }


       if(first == 0) {
	    position = 5 + wall;
	    first++;
       }
   }

   else {
   	movementRobot(-25,500);

	// Resets the gyro on port 2 to 0 degrees
    resetGyro(S2);

  repeatUntil(getGyroDegrees(S2) < -80) {
	// Point turn to the left
	setMotorSpeed(motorC, 50);
	setMotorSpeed(motorB, -50);
  }

	// Stop the motors at the end of the turn
	setMotorSpeed(motorB, 0);
	setMotorSpeed(motorC, 0);

		if(first == 0) {
			position = 1 + wall;
			first++;
		}
   }
}

//This code tells us what starting point we are at 1,2,3 or 4
void boxRoom() { 

	bool booleanCheck = true;

	while(booleanCheck == true) {
		if(SensorValue(S4) > 20) {
			setMotorSpeed(motorC, 15);
			setMotorSpeed(motorB, 15);
			booleanCheck = true;
		}
		else
			booleanCheck = false; 
	}

	gyroTurnRight(90);
	
	if(SensorValue(S4) < 10) {
		
		gyroTurnLeft(-180);
		movementRobot(20, 3000);
		pauseMovement();

		gyroTurnRight(90);
		movementRobot(20, 2500);
		pauseMovement();

		gyroTurnLeft(-90);
		pauseMovement();
	}

	else {
		movementRobot(20, 3500);
		pauseMovement();

		gyroTurnLeft(-90);
		movementRobot(20, 2500);
		pauseMovement();

		gyroTurnRight(90);
		movementRobot(10, 1000);
		pauseMovement();
	}
	counter++;
}


void survivorRoom()
{
	while(SensorValue(S4) > 20) {
		movementRobot(20, 3000);
	}

	movementRobot(-20, 1000);
	moveMotor(arm, -180, degrees, 50);
	sleep(500);
	
	movementRobot(20, 1500);
	moveMotor(arm, 180, degrees, 50);

	gyroTurnRight(90);

	movementRobot(20,1000);
	
}


task main() {

// function call to find the staring position on theb board
startingPosition();

//function call to determine where the wall is relative to the robot.
	switch(position) {
		case 1: boxRoom(); emptyOrRedRoom(); survivorRoom(); break;
		case 2: survivorRoom(); emptyOrRedRoom(); boxRoom(); emptyOrRedRoom(); break;
		case 3: boxRoom(); emptyOrRedRoom(); survivorRoom(); emptyOrRedRoom(); break;
		case 4: survivorRoom(); emptyOrRedRoom(); boxRoom(); break;
		case 5: survivorRoom(); emptyOrRedRoom(); boxRoom(); break;
		case 6: boxRoom(); emptyOrRedRoom(); survivorRoom(); emptyOrRedRoom(); break;
		case 7: survivorRoom(); emptyOrRedRoom(); boxRoom(); emptyOrRedRoom(); break;
		case 8: emptyOrRedRoom(); boxRoom(); emptyOrRedRoom(); survivorRoom(); break;
		
		default: break;
	}
}