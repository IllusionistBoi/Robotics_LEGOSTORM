#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//



//used to store the count of the motor clicks
int leftEncoderCount = 0;
int rightEncoderCount = 0;

//a background task used to monitor the encoders and count the clicks
task encoderTask()
{
  //get the state of the encoders so that we know when they have changed
  // for example if the last state was high and the current state is low
  // or vise-versa, then we know that the encoder incremented another click.
  int lastStateLeft = SensorValue[leftEncoder];
  int lastStateRight = SensorValue[rightEncoder];

  while(true)
  {

    //get the current state of the left encoder
    int state = SensorValue[leftEncoder];

    //has the left encoder changed states
    if (lastStateLeft != state) {
      //if so, then increment the leftEncoderCount by 1
      leftEncoderCount++;

      // then store the current state as the last state so that we can keep monitoring every change
      lastStateLeft = state;
    }

    //repeat for the right encoder.

    state = SensorValue[rightEncoder];
    if (lastStateRight != state) {
      rightEncoderCount++;
      lastStateRight = state;
    }

    //we add a pause between updates to keep from hogging the CPU and
    // so that we debounce the encoders.
    wait1Msec(10);
  }
}

void turnRightDeg(int degrees, int power)
{
  //Reset encoders
  leftEncoderCount = 0;
  rightEncoderCount = 0;

  //Determine tickGoal
  int tickGoal = (8 * degrees) / 119;

  //Start the motors in a left point turn.
  motor[leftServo] = power;
  motor[rightServo] = -1 * power;

  //Since the wheels may go at slightly different speeds due to manufacturing tolerances, etc.,
  //we need to test both encoders and control both motors separately. This may result in one motor
  //going for longer than another but it will ultimately result in a much more accurate turn.
  while(rightEncoderCount < tickGoal || leftEncoderCount < tickGoal) {
    if(rightEncoderCount > tickGoal) {motor[rightServo] = 0;}
    if(leftEncoderCount > tickGoal) {motor[leftServo] = 0;}
  }
  //Make sure both motors stop at the end of the turn.
  motor[leftServo] = 0;
  motor[rightServo] = 0;
}

void turnLeftDeg(int degrees, int power)
{
  //Reset encoders
  leftEncoderCount = 0;
  rightEncoderCount = 0;

  //Determine tickGoal
  int tickGoal = (8 * degrees) / 119;

  //Start the motors in a left point turn.
  motor[leftServo] = -1 * power;
  motor[rightServo] = power;

  //Since the wheels may go at slightly different speeds due to manufacturing tolerances, etc.,
  //we need to test both encoders and control both motors separately. This may result in one motor
  //going for longer than another but it will ultimately result in a much more accurate turn.
  while(rightEncoderCount < tickGoal || leftEncoderCount < tickGoal) {
    if(rightEncoderCount > tickGoal) {motor[rightServo] = 0;}
    if(leftEncoderCount > tickGoal) {motor[leftServo] = 0;}
  }
  //Make sure both motors stop at the end of the turn.
  motor[leftServo] = 0;
  motor[rightServo] = 0;
}

task main()
{
  //Start the encoder monitoring task, which will run in the background.
  StartTask(encoderTask);

  //Turn right 90 degrees with power 30
  turnRightDeg(90,30);

  //Wait a bit so the robot's momentum does not effect the next turn
  wait1Msec(500);

  turnLeftDeg(50,40);
  wait1Msec(500);
  turnRightDeg(160,20);
  wait1Msec(500);
  turnLeftDeg(200,30);
}
