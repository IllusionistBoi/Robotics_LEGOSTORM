#pragma config(Sensor, S1,     touch,          sensorEV3_Touch)
#pragma config(Sensor, S2,     gyro,           sensorEV3_Gyro)
#pragma config(Sensor, S3,     color,          sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonar,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          arm,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,           ,             tmotorEV3_Large, openLoop, driveLeft, encoder)
#pragma config(Motor,  motorC,           ,             tmotorEV3_Large, openLoop, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool isWallOnRight(){

}

//This code tells us what starting point we are at 1,2,3 or 4
int startingPosition(){
int sum=0;
int distance1,distance2,position;

distance1 = SensorValue(S4);


resetGyro(S2);
//turns 180 degrees to check the value for opposite side
   repeatUntil(getGyroDegrees(S2) > 180)
{
	setMotorSpeed(motorC,-25);
	setMotorSpeed(motorB, 25);
}
setMotorSpeed(motorC,0);
setMotorSpeed(motorB,0);
sleep(1000);



distance2= SensorValue(S4);

resetGyro(S2);
repeatUntil(getGyroDegrees(S2) > 180)
{
	setMotorSpeed(motorC,-25);
	setMotorSpeed(motorB, 25);
	}



//the sum of the distances is different from each point hence helping us distinguish the points we are starting at.
sum = distance1 + distance2;
int wall;
if(isWallOnRight()){
wall=0;
}else{
wall=1;
}
if(sum>115)
{
	position=1+wall;
}else if(sum>45 && sum <60){
position=2+wall;

}else if(sum>90 && sum<110){
position=3+wall;

}else if(sum>60 && sum<80){
position=4+wall;

}else{
startingPosition();
}
return position;
}



void emptyRoom(){

	while(SensorValue(S1) == 0) {
	    motor[motorB] = 25;
	    motor[motorC] = 25;
	}
		motor[motorB] = -25;
	motor[motorC] = -25;
sleep(500);

	//Resets the gyro on port 2 to 0 degrees
  resetGyro(S2);

  repeatUntil(getGyroDegrees(S2) < -90)
{
	//Point turn to the left
	setMotorSpeed(motorC, 50);
	setMotorSpeed(motorB, -50);
}

//Stop the motors at the end of the turn
setMotorSpeed(motorB, 0);
setMotorSpeed(motorC, 0);





}




void redRoom(){

	//reaches the fire and backs away a bit.
  motor[motorB] = -25;
	motor[motorC] = -25;
  sleep(500);

  // turns 180 degrees
  resetGyro(S2);
   repeatUntil(getGyroDegrees(S2) > 180)
{
	setMotorSpeed(motorC,-50);
	setMotorSpeed(motorB, 50);
}
	//reverses into the fire
	motor[motorB] = -25;
	motor[motorC] = -25;
  sleep(2000);

  // makes a 90 degree right turn (gyro value was 180 before)
	repeatUntil(getGyroDegrees(S2) > 270)
{
	//Point turn to the left
	setMotorSpeed(motorC,0);
	setMotorSpeed(motorB, 50);

}

}

void boxRoom(){


}

void survivorRoom(){


}








task main(){
int position;
bool wall;

//function call to find the staring position on theb board
position=startingPosition();

//function call to determine where the wall is relative to the robot.
wall=isWallOnRight();

switch(position){
	case 1: emptyRoom(); boxRoom(); redRoom(); survivorRoom(); break;
	case 2: survivorRoom(); redRoom(); boxRoom(); emptyRoom(); break;
	case 3: boxRoom(); redRoom(); survivorRoom(); emptyRoom(); break;
	case 4: emptyRoom(); survivorRoom(); redRoom(); boxRoom(); break;
	case 5: redRoom(); survivorRoom(); emptyRoom(); boxRoom(); break;
	case 6: boxRoom(); emptyRoom(); survivorRoom(); redRoom(); break;
	case 7: survivorRoom(); emptyRoom(); boxRoom(); redRoom(); break;
	case 8: redRoom(); boxRoom(); emptyRoom(); survivorRoom(); break;
	default: break;






}


/*
	while(SensorValue(S1) == 0) {
	  if (getColorName(S3) == colorRed){

	  redRoom();

	  }
	  else {
	    motor[motorB] = 25;
	    motor[motorC] = 25;
	  }
	}

	motor[motorB] = -25;
	motor[motorC] = -25;
sleep(500);

	//Resets the gyro on port 2 to 0 degrees
  resetGyro(S2);

  repeatUntil(getGyroDegrees(S2) < -90)
{
	//Point turn to the left
	setMotorSpeed(motorC, 50);
	setMotorSpeed(motorB, -50);
}

//Stop the motors at the end of the turn
setMotorSpeed(motorB, 0);
setMotorSpeed(motorC, 0);



*/

//This program will reset the gyro's heading and
//then turn the robot 90 degrees from its current position



//Keep looping until the gyro sensor reads greater
//than 90 degrees from its current position



}
